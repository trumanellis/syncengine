#!/bin/bash
# Launch multiple Synchronicity Engine instances with JSONL logging
# Usage: ./se [--no-logs] <name1> [name2] [name3] ...
#        ./se @<scenario>     # Run a Lua scenario
#
# Each instance gets its own data directory and window title.
# On clean launch (no existing databases), profile names are auto-set.
# Logs are captured to JSONL files in ./logs/ by default (use --no-logs to disable).
# Generate human-readable reports with: syncengine-cli logs report
#
# Examples:
#   ./se love           # Single instance (logs to ./logs/raw/YYYY-MM-DD_love.jsonl)
#   ./se love joy       # Two instances side by side
#   ./se alice bob eve  # Three instances for testing sync
#   ./se --no-logs love # Single instance without logging
#   ./se @mesh-3        # Run the mesh-3 scenario (3 nodes in full mesh)
#   ./se @chaos         # Run the chaos scenario (random failures)

set -e

# Colors for output
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Base data directory (macOS)
DATA_BASE="${HOME}/Library/Application Support"

# Default: logging is enabled
ENABLE_LOGS=true

# Default: don't delete data
FRESH_START=false

# Logs directory (in project root)
LOGS_DIR="./logs"

# Process flags first (before checking for @scenario)
while [[ "$1" == --* ]]; do
    case "$1" in
        --no-logs)
            ENABLE_LOGS=false
            shift
            ;;
        --logs)
            # Legacy flag, logs are now on by default
            ENABLE_LOGS=true
            shift
            ;;
        --logs-dir)
            LOGS_DIR="$2"
            shift 2
            ;;
        --fresh)
            FRESH_START=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Check for scenario mode (@scenario-name) AFTER processing flags
if [[ "$1" == @* ]]; then
    SCENARIO_NAME="${1:1}"  # Remove @ prefix
    echo -e "${CYAN}Running scenario: ${YELLOW}${SCENARIO_NAME}${NC}"

    # Build the scenario runner first
    echo -e "${CYAN}Building scenario runner...${NC}"
    cargo build -p syncengine-scenarios 2>&1 | grep -E "(Compiling|Finished|error)" || true

    # Also need to build the main desktop binary and CLI
    echo -e "${CYAN}Building Synchronicity Engine...${NC}"
    cargo build --bin syncengine-desktop 2>&1 | grep -E "(Compiling|Finished|error)" || true
    cargo build -p syncengine-cli 2>&1 | grep -E "(Compiling|Finished|error)" || true

    SCENARIO_BIN="./target/debug/syncengine-scenario"
    if [ ! -f "$SCENARIO_BIN" ]; then
        echo "Scenario runner not found at $SCENARIO_BIN"
        echo "Trying release build..."
        SCENARIO_BIN="./target/release/syncengine-scenario"
    fi

    if [ ! -f "$SCENARIO_BIN" ]; then
        echo -e "${YELLOW}Error: Could not find scenario runner binary${NC}"
        exit 1
    fi

    # Set up logging in scenario subdirectory
    SCENARIO_LOGS_DIR="./scenarios/${SCENARIO_NAME}/logs"
    SCENARIO_REPORT="./scenarios/${SCENARIO_NAME}/LOGS.md"

    if [ "$ENABLE_LOGS" = true ]; then
        # Clear old logs and create fresh directory
        rm -rf "$SCENARIO_LOGS_DIR"
        mkdir -p "$SCENARIO_LOGS_DIR/raw"
        mkdir -p "$SCENARIO_LOGS_DIR/sessions"

        SESSION_ID=$(date '+%Y-%m-%dT%H-%M-%S')
        cat > "$SCENARIO_LOGS_DIR/sessions/${SESSION_ID}.json" << EOF
{
  "session_id": "$SESSION_ID",
  "started_at": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
  "scenario": "$SCENARIO_NAME"
}
EOF

        echo -e "${CYAN}JSONL logging enabled${NC}"
        echo -e "  Logs dir: ${YELLOW}${SCENARIO_LOGS_DIR}${NC}"
    fi

    # Cleanup function for scenarios
    scenario_cleanup() {
        echo ""
        echo -e "${YELLOW}Scenario ended.${NC}"

        if [ "$ENABLE_LOGS" = true ]; then
            sleep 0.5
            echo -e "${CYAN}Generating scenario log report...${NC}"

            CLI_BIN="./target/debug/syncengine"
            if [ ! -f "$CLI_BIN" ]; then
                CLI_BIN="./target/release/syncengine"
            fi

            if [ -f "$CLI_BIN" ]; then
                if "$CLI_BIN" logs report --logs-dir "$SCENARIO_LOGS_DIR" --output "$SCENARIO_REPORT" 2>/dev/null; then
                    echo -e "${GREEN}Report saved to ${SCENARIO_REPORT}${NC}"

                    # Symlink to project root LOGS.md
                    rm -f "./LOGS.md"
                    ln -s "$SCENARIO_REPORT" "./LOGS.md"
                    echo -e "${GREEN}Symlinked to ./LOGS.md${NC}"
                else
                    echo -e "${YELLOW}Report generation failed${NC}"
                fi
            fi

            echo ""
            echo -e "${CYAN}Raw logs available at:${NC}"
            ls -la "$SCENARIO_LOGS_DIR/raw/"*.jsonl 2>/dev/null || echo "  (no logs found)"
        fi

        exit 0
    }

    trap scenario_cleanup SIGINT SIGTERM EXIT

    # Build scenario runner arguments
    SCENARIO_ARGS="$SCENARIO_NAME --verbose"
    if [ "$FRESH_START" = true ]; then
        SCENARIO_ARGS="$SCENARIO_ARGS --fresh"
        echo -e "${YELLOW}Fresh start: deleting existing instance data${NC}"
    fi

    # Run the scenario with logging environment variables
    if [ "$ENABLE_LOGS" = true ]; then
        SYNCENGINE_LOGS_DIR="$SCENARIO_LOGS_DIR" \
        SYNCENGINE_INSTANCE="scenario-${SCENARIO_NAME}" \
        RUST_LOG=syncengine=info,syncengine_core=info \
        "$SCENARIO_BIN" $SCENARIO_ARGS
    else
        "$SCENARIO_BIN" $SCENARIO_ARGS
    fi

    exit 0
fi

# Show usage if no arguments
if [ $# -eq 0 ]; then
    echo "Usage: ./se [options] <name1> [name2] [name3] ..."
    echo "       ./se [options] @<scenario>     # Run a Lua scenario"
    echo ""
    echo "Options:"
    echo "  --no-logs           Disable JSONL log capture"
    echo "  --logs-dir <dir>    Set custom logs directory (default: ./logs)"
    echo "  --fresh             Delete existing data before starting (clean test run)"
    echo ""
    echo "Examples:"
    echo "  ./se love           # Single instance (with JSONL logging)"
    echo "  ./se love joy       # Two instances"
    echo "  ./se alice bob eve  # Three instances"
    echo "  ./se --no-logs love # Without logging"
    echo "  ./se --fresh @offline-relay  # Clean run of scenario"
    echo ""
    echo "Scenarios:"
    echo "  ./se @mesh-3           # 3 nodes in full mesh topology"
    echo "  ./se @mesh-messaging   # Full mesh with direct messaging test"
    echo "  ./se @offline-relay    # Store-and-forward relay test"
    echo "  ./se @hub-spoke        # Central hub with satellite nodes"
    echo "  ./se @staggered-join   # Nodes join at different times"
    echo "  ./se @chaos            # Random node failures for resilience testing"
    echo ""
    echo "Logs:"
    echo "  Logs are stored in $LOGS_DIR/raw/*.jsonl (one file per instance)"
    echo "  Generate report: cargo run -p syncengine-cli -- logs report"
    echo "  Query logs: jq 'select(.level == \"error\")' $LOGS_DIR/raw/*.jsonl"
    echo ""
    echo "Each instance gets its own data directory:"
    echo "  ~/Library/Application Support/instance-<name>/"
    exit 1
fi

# Initialize logs directory if logging is enabled
SESSION_ID=""
if [ "$ENABLE_LOGS" = true ]; then
    # Clear old logs and create fresh directory structure
    rm -rf "$LOGS_DIR"
    mkdir -p "$LOGS_DIR/raw"
    mkdir -p "$LOGS_DIR/sessions"

    # Generate session ID
    SESSION_ID=$(date '+%Y-%m-%dT%H-%M-%S')

    # Write session metadata
    cat > "$LOGS_DIR/sessions/${SESSION_ID}.json" << EOF
{
  "session_id": "$SESSION_ID",
  "started_at": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
  "instances": [$(printf '"%s",' "$@" | sed 's/,$//')]
}
EOF

    echo -e "${CYAN}JSONL logging enabled (fresh session)${NC}"
    echo -e "  Session: ${YELLOW}${SESSION_ID}${NC}"
    echo -e "  Logs dir: ${YELLOW}${LOGS_DIR}${NC}"
fi

# Check if any instance needs initialization (for info message)
HAS_NEW_INSTANCE=false
for name in "$@"; do
    db_path="${DATA_BASE}/instance-${name}/syncengine.redb"
    if [ ! -f "$db_path" ]; then
        HAS_NEW_INSTANCE=true
        break
    fi
done

if [ "$HAS_NEW_INSTANCE" = true ]; then
    echo -e "${CYAN}New instance(s) detected - profile names will be auto-set${NC}"
fi

# If launching multiple instances, set up auto-connect
CONNECT_NAMES=""
if [ $# -gt 1 ]; then
    # Build comma-separated list of all names (lowercase)
    for name in "$@"; do
        lower_name=$(echo "$name" | tr '[:upper:]' '[:lower:]')
        if [ -z "$CONNECT_NAMES" ]; then
            CONNECT_NAMES="$lower_name"
        else
            CONNECT_NAMES="$CONNECT_NAMES,$lower_name"
        fi
    done

    # Clean bootstrap directory for fresh connections
    BOOTSTRAP_DIR="${DATA_BASE}/syncengine-bootstrap"
    if [ "$HAS_NEW_INSTANCE" = true ]; then
        echo -e "${CYAN}Clearing bootstrap directory for fresh start${NC}"
        rm -rf "$BOOTSTRAP_DIR"
    fi

    echo -e "${CYAN}Auto-connect enabled for: ${YELLOW}$CONNECT_NAMES${NC}"
fi

# Build first (only once)
echo -e "${CYAN}Building Synchronicity Engine...${NC}"
cargo build --bin syncengine-desktop 2>&1 | grep -E "(Compiling|Finished|error)" || true
echo -e "${GREEN}Build complete.${NC}"
echo ""

# Get the binary path
BINARY="./target/debug/syncengine-desktop"

if [ ! -f "$BINARY" ]; then
    echo "Binary not found at $BINARY"
    echo "Trying release build..."
    BINARY="./target/release/syncengine-desktop"
fi

# Launch each instance
PIDS=()
TOTAL=$#
INDEX=0

for name in "$@"; do
    # Determine position based on total count and index
    if [ "$TOTAL" -eq 1 ]; then
        POSITION="maximized"
    elif [ "$TOTAL" -eq 2 ]; then
        if [ "$INDEX" -eq 0 ]; then
            POSITION="left"
        else
            POSITION="right"
        fi
    elif [ "$TOTAL" -eq 3 ]; then
        if [ "$INDEX" -eq 0 ]; then
            POSITION="left"
        elif [ "$INDEX" -eq 1 ]; then
            POSITION="center"
        else
            POSITION="right"
        fi
    else
        # More than 3: just use left/right alternating (not ideal, but functional)
        if [ $((INDEX % 2)) -eq 0 ]; then
            POSITION="left"
        else
            POSITION="right"
        fi
    fi

    echo -e "${CYAN}Launching instance: ${YELLOW}$name${NC} (${POSITION})"

    # Check if this instance needs profile initialization
    db_path="${DATA_BASE}/instance-${name}/syncengine.redb"
    INIT_ARGS=""
    if [ ! -f "$db_path" ]; then
        # Capitalize first letter of name for display
        DISPLAY_NAME="$(echo "${name:0:1}" | tr '[:lower:]' '[:upper:]')${name:1}"
        INIT_ARGS="--init-profile-name $DISPLAY_NAME"
        echo -e "  ${CYAN}Will set profile name to '${DISPLAY_NAME}'${NC}"
    fi

    # Add auto-connect args if launching multiple instances
    if [ -n "$CONNECT_NAMES" ]; then
        INIT_ARGS="$INIT_ARGS --init-connect $CONNECT_NAMES"
    fi

    # Launch in background with JSONL logging environment variables
    if [ "$ENABLE_LOGS" = true ]; then
        # Set environment variables for JSONL logging
        SYNCENGINE_LOGS_DIR="$LOGS_DIR" \
        SYNCENGINE_INSTANCE="$name" \
        RUST_LOG=syncengine=info,syncengine_core=info \
        "$BINARY" --name "$name" --position "$POSITION" --total-windows "$TOTAL" $INIT_ARGS &
        PIDS+=($!)
        echo -e "  ${CYAN}Logging to: ${YELLOW}${LOGS_DIR}/raw/$(date '+%Y-%m-%d')_${name}.jsonl${NC}"
    else
        # Normal mode (no logging)
        "$BINARY" --name "$name" --position "$POSITION" --total-windows "$TOTAL" $INIT_ARGS &
        PIDS+=($!)
    fi

    INDEX=$((INDEX + 1))

    # Small delay between launches to avoid race conditions
    sleep 0.5
done

echo ""
echo -e "${GREEN}Launched ${#PIDS[@]} instance(s): $@${NC}"
echo ""
echo "Press Ctrl+C to stop all instances"

# Wait for all instances (or Ctrl+C)
cleanup() {
    echo ""
    echo -e "${YELLOW}Stopping all instances...${NC}"

    # First, try graceful termination (SIGTERM)
    for pid in "${PIDS[@]}"; do
        kill "$pid" 2>/dev/null || true
    done

    # Give processes a moment to exit gracefully
    sleep 0.3

    # Force kill any that didn't respond (SIGKILL)
    for pid in "${PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "${YELLOW}Force killing PID $pid...${NC}"
            kill -9 "$pid" 2>/dev/null || true
        fi
    done

    # Also kill any child processes by name (belt and suspenders)
    pkill -9 -f "syncengine-desktop" 2>/dev/null || true

    # Generate report if logging was enabled
    if [ "$ENABLE_LOGS" = true ]; then
        # Give processes time to flush final logs
        sleep 0.5

        echo -e "${CYAN}Generating log report...${NC}"

        # Try to use pre-built CLI binary (faster than cargo run)
        CLI_BIN="./target/debug/syncengine"
        if [ ! -f "$CLI_BIN" ]; then
            CLI_BIN="./target/release/syncengine"
        fi

        if [ -f "$CLI_BIN" ]; then
            if "$CLI_BIN" logs report --logs-dir "$LOGS_DIR" --output LOGS.md 2>/dev/null; then
                echo -e "${GREEN}Report saved to LOGS.md${NC}"
            else
                echo -e "${YELLOW}Report generation failed${NC}"
            fi
        else
            # Fall back to cargo run
            echo -e "${CYAN}Building CLI for report generation...${NC}"
            if cargo run -p syncengine-cli --quiet -- logs report --logs-dir "$LOGS_DIR" --output LOGS.md 2>/dev/null; then
                echo -e "${GREEN}Report saved to LOGS.md${NC}"
            else
                echo -e "${YELLOW}Report generation skipped${NC}"
                echo -e "Generate manually: cargo run -p syncengine-cli -- logs report"
            fi
        fi

        echo ""
        echo -e "${CYAN}Raw logs available at:${NC}"
        ls -la "$LOGS_DIR/raw/"*.jsonl 2>/dev/null || echo "  (no logs found)"
        echo ""
        echo -e "${CYAN}Query examples:${NC}"
        echo "  # Find all errors"
        echo "  jq 'select(.level == \"error\")' $LOGS_DIR/raw/*.jsonl"
        echo ""
        echo "  # Get logs for specific instance"
        echo "  jq 'select(.instance == \"love\")' $LOGS_DIR/raw/*.jsonl"
    fi

    echo -e "${GREEN}All instances stopped.${NC}"
    exit 0
}

trap cleanup SIGINT SIGTERM EXIT

# Wait for any instance to exit
wait
