#!/bin/bash
# Launch multiple Synchronicity Engine instances
# Usage: ./se [--logs] <name1> [name2] [name3] ...
#        ./se @<scenario>     # Run a Lua scenario
#
# Each instance gets its own data directory and window title.
# On clean launch (no existing databases), profile names are auto-set.
#
# Examples:
#   ./se love           # Single instance named "love"
#   ./se love joy       # Two instances side by side
#   ./se alice bob eve  # Three instances for testing sync
#   ./se --logs love    # Single instance with logging to LOGS.md
#   ./se @mesh-3        # Run the mesh-3 scenario (3 nodes in full mesh)
#   ./se @chaos         # Run the chaos scenario (random failures)

set -e

# Colors for output
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Base data directory (macOS)
DATA_BASE="${HOME}/Library/Application Support"

# Check for scenario mode (@scenario-name)
if [[ "$1" == @* ]]; then
    SCENARIO_NAME="${1:1}"  # Remove @ prefix
    echo -e "${CYAN}Running scenario: ${YELLOW}${SCENARIO_NAME}${NC}"

    # Build the scenario runner first
    echo -e "${CYAN}Building scenario runner...${NC}"
    cargo build -p syncengine-scenarios --release 2>&1 | grep -E "(Compiling|Finished|error)" || true

    # Also need to build the main desktop binary
    echo -e "${CYAN}Building Synchronicity Engine...${NC}"
    cargo build --bin syncengine-desktop --release 2>&1 | grep -E "(Compiling|Finished|error)" || true

    SCENARIO_BIN="./target/release/syncengine-scenario"
    if [ ! -f "$SCENARIO_BIN" ]; then
        echo "Scenario runner not found at $SCENARIO_BIN"
        echo "Trying debug build..."
        SCENARIO_BIN="./target/debug/syncengine-scenario"
    fi

    if [ ! -f "$SCENARIO_BIN" ]; then
        echo -e "${YELLOW}Error: Could not find scenario runner binary${NC}"
        exit 1
    fi

    # Run the scenario
    exec "$SCENARIO_BIN" "$SCENARIO_NAME" --verbose
fi

# Check for --logs flag
ENABLE_LOGS=false
if [ "$1" == "--logs" ]; then
    ENABLE_LOGS=true
    shift # Remove --logs from arguments

    # Initialize LOGS.md with better structure
    cat > LOGS.md << 'EOF'
# Synchronicity Engine - Run Logs

EOF
    echo "**Started:** $(date '+%Y-%m-%d %H:%M:%S')" >> LOGS.md
    echo "" >> LOGS.md
    echo "## Session Info" >> LOGS.md
    echo "" >> LOGS.md
    echo "- **Instances:** \`$@\`" >> LOGS.md
    echo "- **Log Level:** INFO" >> LOGS.md
    echo "" >> LOGS.md
    echo "---" >> LOGS.md
    echo "" >> LOGS.md
fi

if [ $# -eq 0 ]; then
    echo "Usage: ./se [--logs] <name1> [name2] [name3] ..."
    echo "       ./se @<scenario>     # Run a Lua scenario"
    echo ""
    echo "Options:"
    echo "  --logs              Capture all logs to LOGS.md"
    echo ""
    echo "Examples:"
    echo "  ./se love           # Single instance"
    echo "  ./se love joy       # Two instances"
    echo "  ./se alice bob eve  # Three instances"
    echo "  ./se --logs love    # With logging enabled"
    echo ""
    echo "Scenarios:"
    echo "  ./se @mesh-3        # 3 nodes in full mesh topology"
    echo "  ./se @hub-spoke     # Central hub with satellite nodes"
    echo "  ./se @staggered-join  # Nodes join at different times"
    echo "  ./se @chaos         # Random node failures for resilience testing"
    echo ""
    echo "Each instance gets its own data directory:"
    echo "  ~/Library/Application Support/instance-<name>/"
    exit 1
fi

# Check if any instance needs initialization (for info message)
HAS_NEW_INSTANCE=false
for name in "$@"; do
    db_path="${DATA_BASE}/instance-${name}/syncengine.redb"
    if [ ! -f "$db_path" ]; then
        HAS_NEW_INSTANCE=true
        break
    fi
done

if [ "$HAS_NEW_INSTANCE" = true ]; then
    echo -e "${CYAN}New instance(s) detected - profile names will be auto-set${NC}"
fi

# If launching multiple instances, set up auto-connect
CONNECT_NAMES=""
if [ $# -gt 1 ]; then
    # Build comma-separated list of all names (lowercase)
    for name in "$@"; do
        lower_name=$(echo "$name" | tr '[:upper:]' '[:lower:]')
        if [ -z "$CONNECT_NAMES" ]; then
            CONNECT_NAMES="$lower_name"
        else
            CONNECT_NAMES="$CONNECT_NAMES,$lower_name"
        fi
    done

    # Clean bootstrap directory for fresh connections
    BOOTSTRAP_DIR="${DATA_BASE}/syncengine-bootstrap"
    if [ "$HAS_NEW_INSTANCE" = true ]; then
        echo -e "${CYAN}Clearing bootstrap directory for fresh start${NC}"
        rm -rf "$BOOTSTRAP_DIR"
    fi

    echo -e "${CYAN}Auto-connect enabled for: ${YELLOW}$CONNECT_NAMES${NC}"
fi

# Build first (only once)
echo -e "${CYAN}Building Synchronicity Engine...${NC}"
cargo build --bin syncengine-desktop --release 2>&1 | grep -E "(Compiling|Finished|error)" || true
echo -e "${GREEN}Build complete.${NC}"
echo ""

# Get the binary path
BINARY="./target/release/syncengine-desktop"

if [ ! -f "$BINARY" ]; then
    echo "Binary not found at $BINARY"
    echo "Trying debug build..."
    BINARY="./target/debug/syncengine-desktop"
fi

# Launch each instance
PIDS=()
TOTAL=$#
INDEX=0

for name in "$@"; do
    # Determine position based on total count and index
    if [ "$TOTAL" -eq 1 ]; then
        POSITION="maximized"
    elif [ "$TOTAL" -eq 2 ]; then
        if [ "$INDEX" -eq 0 ]; then
            POSITION="left"
        else
            POSITION="right"
        fi
    elif [ "$TOTAL" -eq 3 ]; then
        if [ "$INDEX" -eq 0 ]; then
            POSITION="left"
        elif [ "$INDEX" -eq 1 ]; then
            POSITION="center"
        else
            POSITION="right"
        fi
    else
        # More than 3: just use left/right alternating (not ideal, but functional)
        if [ $((INDEX % 2)) -eq 0 ]; then
            POSITION="left"
        else
            POSITION="right"
        fi
    fi

    echo -e "${CYAN}Launching instance: ${YELLOW}$name${NC} (${POSITION})"

    # Check if this instance needs profile initialization
    db_path="${DATA_BASE}/instance-${name}/syncengine.redb"
    INIT_ARGS=""
    if [ ! -f "$db_path" ]; then
        # Capitalize first letter of name for display
        DISPLAY_NAME="$(echo "${name:0:1}" | tr '[:lower:]' '[:upper:]')${name:1}"
        INIT_ARGS="--init-profile-name $DISPLAY_NAME"
        echo -e "  ${CYAN}Will set profile name to '${DISPLAY_NAME}'${NC}"
    fi

    # Add auto-connect args if launching multiple instances
    if [ -n "$CONNECT_NAMES" ]; then
        INIT_ARGS="$INIT_ARGS --init-connect $CONNECT_NAMES"
    fi

    # Launch in background with position and total count
    if [ "$ENABLE_LOGS" = true ]; then
        # Add instance header to logs
        echo "## Instance: \`$name\`" >> LOGS.md
        echo "" >> LOGS.md
        echo "<details>" >> LOGS.md
        echo "<summary>Click to expand logs</summary>" >> LOGS.md
        echo "" >> LOGS.md
        echo "\`\`\`log" >> LOGS.md

        # With logging enabled - Rust tracing already adds timestamps
        RUST_LOG=syncengine=info,syncengine_core=info "$BINARY" --name "$name" --position "$POSITION" --total-windows "$TOTAL" $INIT_ARGS 2>&1 | tee -a LOGS.md &
        PIDS+=($!)
    else
        # Normal mode (no logging)
        "$BINARY" --name "$name" --position "$POSITION" --total-windows "$TOTAL" $INIT_ARGS &
        PIDS+=($!)
    fi

    INDEX=$((INDEX + 1))

    # Small delay between launches to avoid race conditions
    sleep 0.5
done

echo ""
echo -e "${GREEN}Launched ${#PIDS[@]} instance(s): $@${NC}"
echo ""
echo "Press Ctrl+C to stop all instances"

# Wait for all instances (or Ctrl+C)
cleanup() {
    echo ""
    echo -e "${YELLOW}Stopping all instances...${NC}"

    # First, try graceful termination (SIGTERM)
    for pid in "${PIDS[@]}"; do
        kill "$pid" 2>/dev/null || true
    done

    # Give processes a moment to exit gracefully
    sleep 0.3

    # Force kill any that didn't respond (SIGKILL)
    for pid in "${PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "${YELLOW}Force killing PID $pid...${NC}"
            kill -9 "$pid" 2>/dev/null || true
        fi
    done

    # Also kill any child processes by name (belt and suspenders)
    pkill -9 -f "syncengine-desktop" 2>/dev/null || true

    # Close markdown sections if logging was enabled
    if [ "$ENABLE_LOGS" = true ]; then
        # Give processes time to flush final logs
        sleep 0.2

        # Close the final code block and details
        echo "\`\`\`" >> LOGS.md
        echo "" >> LOGS.md
        echo "</details>" >> LOGS.md
        echo "" >> LOGS.md

        # Add session summary
        echo "---" >> LOGS.md
        echo "" >> LOGS.md
        echo "## Session Summary" >> LOGS.md
        echo "" >> LOGS.md
        echo "- **Ended:** $(date '+%Y-%m-%d %H:%M:%S')" >> LOGS.md
        echo "- **Duration:** ~$((SECONDS / 60)) minutes" >> LOGS.md
        echo "" >> LOGS.md

        # Count log entries by level
        INFO_COUNT=$(grep -c "INFO" LOGS.md 2>/dev/null || echo "0")
        WARN_COUNT=$(grep -c "WARN" LOGS.md 2>/dev/null || echo "0")
        ERROR_COUNT=$(grep -c "ERROR" LOGS.md 2>/dev/null || echo "0")

        echo "### Log Statistics" >> LOGS.md
        echo "" >> LOGS.md
        echo "| Level | Count |" >> LOGS.md
        echo "|-------|-------|" >> LOGS.md
        echo "| INFO  | $INFO_COUNT |" >> LOGS.md
        echo "| WARN  | $WARN_COUNT |" >> LOGS.md
        echo "| ERROR | $ERROR_COUNT |" >> LOGS.md

        echo -e "${GREEN}Logs saved to LOGS.md${NC}"
    fi

    echo -e "${GREEN}All instances stopped.${NC}"
    exit 0
}

trap cleanup SIGINT SIGTERM EXIT

# Wait for any instance to exit
wait
